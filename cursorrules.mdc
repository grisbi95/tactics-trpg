---
description:
globs:
alwaysApply: false
---
# Cursor Rules - TRPG Tactics (Godot 4.4)

## üéØ Contexte du Projet
- **Type**: Tactical Role Playing Game (TRPG)
- **Moteur**: Godot 4.4
- **Niveau**: D√©veloppeur hobbyiste
- **Philosophie**: Simple, clair et organis√© sans over-engineering

## üìÅ Structure du Projet

### Architecture des Dossiers
```
tactics/
‚îú‚îÄ‚îÄ scenes/          # Sc√®nes principales (.tscn)
‚îÇ   ‚îú‚îÄ‚îÄ game/        # Sc√®nes de jeu (bataille, carte)
‚îÇ   ‚îú‚îÄ‚îÄ ui/          # Interfaces utilisateur
‚îÇ   ‚îî‚îÄ‚îÄ characters/  # Sc√®nes de personnages
‚îú‚îÄ‚îÄ scripts/         # Scripts GDScript (.gd)
‚îÇ   ‚îú‚îÄ‚îÄ core/        # Syst√®mes principaux
‚îÇ   ‚îú‚îÄ‚îÄ characters/  # Scripts de personnages
‚îÇ   ‚îú‚îÄ‚îÄ ui/          # Scripts d'UI
‚îÇ   ‚îî‚îÄ‚îÄ utilities/   # Utilitaires et helpers
‚îú‚îÄ‚îÄ resources/       # Ressources r√©utilisables (.tres, .res)
‚îÇ   ‚îú‚îÄ‚îÄ data/        # Donn√©es de jeu (stats, items)
‚îÇ   ‚îî‚îÄ‚îÄ themes/      # Th√®mes UI
‚îú‚îÄ‚îÄ assets/          # Assets media
‚îÇ   ‚îú‚îÄ‚îÄ sprites/     # Images et textures
‚îÇ   ‚îú‚îÄ‚îÄ audio/       # Sons et musiques
‚îÇ   ‚îî‚îÄ‚îÄ fonts/       # Polices
‚îî‚îÄ‚îÄ addons/          # Plugins Godot
```

## üíª Conventions de Code GDScript

### Nommage
- **Classes**: PascalCase (`BattleManager`, `CharacterController`)
- **Variables**: snake_case (`current_health`, `move_range`)
- **Constantes**: SCREAMING_SNAKE_CASE (`MAX_LEVEL`, `DAMAGE_MULTIPLIER`)
- **Fonctions**: snake_case (`calculate_damage()`, `move_to_position()`)
- **Signaux**: snake_case avec pr√©fixe descriptif (`health_changed`, `turn_ended`)
- **N≈ìuds**: PascalCase dans l'√©diteur, snake_case en code

### Structure des Scripts
```gdscript
class_name MonNom
extends Node

#region SIGNAUX
signal health_changed(new_value: int)
signal died
#endregion

#region CONSTANTES
const MAX_HEALTH: int = 100
#endregion

#region VARIABLES EXPORT√âES
@export var speed: float = 200.0
@export var damage: int = 10
#endregion

#region VARIABLES PRIV√âES
var _current_health: int
var _is_moving: bool = false
#endregion

#region FONCTIONS VIRTUELLES
func _ready() -> void:
	pass

func _process(delta: float) -> void:
	pass
#endregion

#region FONCTIONS PUBLIQUES
func take_damage(amount: int) -> void:
	pass
#endregion

#region FONCTIONS PRIV√âES
func _calculate_something() -> int:
	return 0
#endregion
```

## üéÆ Bonnes Pratiques TRPG

### Syst√®me de Combat
- Utiliser des `Resource` pour les stats des personnages
- S√©parer la logique de combat de l'affichage
- Impl√©menter un syst√®me de tour par tour avec `signals`
- Utiliser des `enums` pour les types d'actions et d'unit√©s

### Gestion de la Grille
- Cr√©er une classe `GridManager` pour g√©rer les positions
- Utiliser `Vector2i` pour les coordonn√©es de grille
- S√©parer les coordonn√©es monde des coordonn√©es grille

### Sauvegarde/Chargement
- Utiliser le syst√®me `Resource` de Godot pour les donn√©es persistantes
- Sauvegarder uniquement les donn√©es essentielles
- Impl√©menter un syst√®me de versioning simple

## üèóÔ∏è Architecture Flexible

### Respect de la Hi√©rarchie
- **R√®gle d'or**: Les d√©pendances ne remontent jamais dans la hi√©rarchie
- **Communication descendante**: Parent ‚Üí Enfant (appels directs)
- **Communication ascendante**: Enfant ‚Üí Parent (`signals` uniquement)
- **Communication lat√©rale**: Via un parent commun ou `signals`

```gdscript
# ‚úÖ Bon - Communication par signals
signal health_changed(new_health: int)
signal player_died

# ‚ùå Mauvais - R√©f√©rence vers le parent
# get_parent().get_node("UI").update_health()
```

### D√©couplage avec les Signals
- **Observer Pattern**: Utiliser les `signals` pour d√©coupler les syst√®mes
- **√âviter**: Les r√©f√©rences directes entre objets de m√™me niveau
- **Privil√©gier**: Un syst√®me de messaging via `signals`

```gdscript
# ‚úÖ Bon - D√©coupl√©
func _on_enemy_died(enemy: Enemy) -> void:
	score += enemy.points
	enemies_killed += 1
	enemy_died.emit(enemy)

# ‚ùå Mauvais - Couplage fort
func _on_enemy_died(enemy: Enemy) -> void:
	get_node("/root/GameManager").add_score(enemy.points)
	get_node("/root/UI/HUD").update_enemies_count()
```

### Composants R√©utilisables
- **Principe**: Cr√©er des composants ind√©pendants
- **Exemple**: `HealthComponent`, `MovementComponent`, `AttackComponent`
- **Avantage**: R√©utilisabilit√© et facilit√© de test

## üöÄ Performance et Optimisation

### R√®gles G√©n√©rales
- √âviter les `get_node()` r√©p√©t√©s, utiliser `@onready var`
- Pr√©f√©rer les `signals` aux v√©rifications constantes dans `_process()`
- Utiliser `call_deferred()` pour les op√©rations lourdes
- Limiter les effets visuels simultan√©s

### Gestion M√©moire
- Lib√©rer les ressources avec `queue_free()`
- √âviter les r√©f√©rences circulaires
- Utiliser `WeakRef` quand n√©cessaire

## üé® Interface Utilisateur

### Conventions UI
- Utiliser des `Themes` pour la coh√©rence visuelle
- S√©parer les scripts UI de la logique de jeu
- Impl√©menter une architecture MVC simple
- Utiliser des `Control` nodes appropri√©s

### Responsive Design
- Utiliser les `Anchors` et `Margins` correctement
- Tester sur diff√©rentes r√©solutions
- Impl√©menter un syst√®me de scaling UI

## üîß D√©veloppement et Debugging

### Organisation du Code
- Une classe par fichier
- Maximum 300 lignes par script (indicatif)
- Commentaires en fran√ßais pour la logique complexe
- Documentation des fonctions publiques

### Tests et Debug
- Utiliser `print_debug()` au lieu de `print()`
- Impl√©menter des modes debug avec des variables export√©es
- Ajouter des assertions pour les cas critiques
- Utiliser le debugger int√©gr√© de Godot

## üìã Standards de Commit

### Messages de Commit
- `feat:` nouvelles fonctionnalit√©s
- `fix:` corrections de bugs
- `refactor:` refactoring de code
- `ui:` modifications d'interface
- `assets:` ajout/modification d'assets
- `docs:` documentation

Exemple: `feat: ajout du syst√®me de mouvement sur grille`

## üö´ Code Smells √† √âviter

### Fonctions Trop Longues
- **Limite**: ~20 lignes maximum par fonction
- **Principe**: Une fonction = une responsabilit√©
- **Solution**: Diviser en fonctions plus petites et r√©utilisables

```gdscript
# ‚ùå Mauvais - Fonction qui fait trop de choses
func take_damage(amount: int) -> void:
	var final_damage = amount * defense_modifier
	current_health -= final_damage
	health_bar.value = current_health
	if current_health <= 0:
		is_alive = false
		play_animation("death")
	damage_sfx.play()
	damage_particles.emit()

# ‚úÖ Bon - Fonctions sp√©cialis√©es
func take_damage(amount: int) -> void:
	var final_damage = _calculate_damage(amount)
	_update_health(final_damage)
	_update_ui()
	_play_effects()
```

### Listes de Param√®tres Trop Longues
- **Limite**: Maximum 4-5 param√®tres
- **Solutions**:
  - Utiliser des `Resource` pour grouper les donn√©es
  - Cr√©er des fonctions plus sp√©cifiques
  - Utiliser des dictionnaires pour les options

```gdscript
# ‚ùå Mauvais - Trop de param√®tres
func attack(target, damage, type, critical, elemental_type, status_effect, duration):
	pass

# ‚úÖ Bon - Utiliser une Resource
class_name AttackData extends Resource
@export var damage: int
@export var type: String
@export var is_critical: bool

func attack(target: Node, attack_data: AttackData) -> void:
	pass
```

### Code Dupliqu√©
- **R√®gle**: DRY (Don't Repeat Yourself)
- **Solution**: Cr√©er des fonctions utilitaires ou classes partag√©es

### God Objects (Objets Dieu)
- **Probl√®me**: Un objet qui fait tout
- **Solution**: S√©parer les responsabilit√©s, utiliser des `signals` pour la communication

### Sur-ing√©nierie
- **Principe**: KISS (Keep It Simple, Stupid)
- **√âviter**: Patterns complexes non n√©cessaires
- **Privil√©gier**: Solutions simples qui fonctionnent

## ‚úÖ Checklist Avant Commit

- [ ] Le code suit les conventions de nommage
- [ ] Pas de `print()` oubli√© (utiliser `print_debug()`)
- [ ] Les variables export√©es ont des valeurs par d√©faut sens√©es
- [ ] Les signaux sont bien document√©s
- [ ] Le code est comment√© si n√©cessaire
- [ ] Pas de warnings dans l'√©diteur
- [ ] Les sc√®nes sont organis√©es logiquement

## üéØ Objectifs de Simplicit√©

### Pour un D√©veloppeur Hobbyiste
1. **Clart√© avant performance**: Code lisible > code optimis√©
2. **Fonctionnalit√© avant perfection**: Faire fonctionner > rendre parfait
3. **It√©ration rapide**: Petites fonctionnalit√©s testables
4. **Documentation minimale**: Commenter le "pourquoi", pas le "comment"

### Architecture KISS (Keep It Simple, Stupid)
- Pas plus de 3 niveaux d'h√©ritage
- √âviter les patterns complexes si non n√©cessaires
- Pr√©f√©rer la composition √† l'h√©ritage
- Une responsabilit√© par classe

### Approche It√©rative
1. **Commencer simple**: Impl√©mentez d'abord la version basique qui fonctionne
2. **Identifier les pain points**: Attendez de ressentir la douleur avant d'optimiser
3. **Refactorer intelligemment**:
   - Quelles fonctionnalit√©s sont **requises** ?
   - Quelles fonctionnalit√©s sont **probablement n√©cessaires** ?
   - Quel est l'**impact et la port√©e** du code ?
4. **√âviter la sur-optimisation pr√©coce**: Un jeu m√©diocre qui sort > un jeu parfait qui ne sort jamais

### Questions √† se Poser
- "Cette complexit√© est-elle justifi√©e par un besoin r√©el ?"
- "Puis-je r√©soudre ce probl√®me plus simplement ?"
- "Cette abstraction sera-t-elle r√©ellement r√©utilis√©e ?"
- "Le gain en flexibilit√© vaut-il la complexit√© ajout√©e ?"

## üìö Ressources Recommand√©es

Ces r√®gles s'inspirent des meilleures pratiques de d√©veloppement de jeux :
- [Code Smells √† √©viter](mdc:https:/shaggydev.com/2023/01/16/code-smells) - Identifier et corriger les probl√®mes de code
- [Code Flexible](mdc:https:/shaggydev.com/2022/09/13/flexible-code) - √âcrire du code adaptable et maintenable
- [Observer Pattern](mdc:https:/shaggydev.com/2022/06/01/observer-pattern) - Communication d√©coupl√©e avec les signals
- [Clean Code](mdc:https:/shaggydev.com/2022/05/04/clean-code) - Principes de code propre

---

*Ce fichier sera mis √† jour selon l'√©volution du projet. Restez simple, restez organis√© !*
